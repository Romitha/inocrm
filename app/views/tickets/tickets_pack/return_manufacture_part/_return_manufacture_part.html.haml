- uri = URI(request.url)
.row
  .col-md-4
    %dl.dl-horizontal
      %dt Part Status:
      %dd= ticket_spare_part.spare_part_status_action.name

      %dt Product Brand:
      %dd= product.product_brand.name

      %dt Spare part No:
      %dd= ticket_spare_part.spare_part_no

      %dt Part Description:
      %dd= ticket_spare_part.spare_part_description

      %dt Faulty Part Serial No:
      %dd= ticket_spare_part.faulty_serial_no

      %dt Faulty part CT No:
      %dd= ticket_spare_part.faulty_ct_no

  .col-md-4
    %dl.dl-horizontal

      %dt Part order No:
      %dd= ticket_spare_part.ticket_spare_part_manufacture.try(:part_no)

      %dt Part event No:
      %dd= ticket_spare_part.ticket_spare_part_manufacture.try(:event_no)

      %dt Received Spare Part No:
      %dd= ticket_spare_part.received_spare_part_no

      %dt Received part serial No:
      %dd= ticket_spare_part.received_part_serial_no

      %dt Received Part CT No:
      %dd= ticket_spare_part.received_part_ct_no

  .col-md-4
    %dl.dl-horizontal

      %dt Used Status:
      %dd= ticket_spare_part.spare_part_status_use.name

      %dt Un used reason:
      %dd= ticket_spare_part.unused_reason.try(:reason)

      %dt Return Part Serial No:
      %dd= ticket_spare_part.return_part_serial_no

      %dt Return part CT No:
      %dd= ticket_spare_part.return_part_ct_no

.row
  .col-md-12
    = simple_nested_form_for ticket_spare_part, url: update_return_manufacture_part_tickets_path, method: :post do |f|
      = f.input :id, as: :hidden
      .accept_returned_part
        = f.input :returned_part_accepted, as: :radio_buttons, collection: {"Accept Returned Part" => true, "Reject Return Part" => false}, label:false, wrapper: :append, checked: true

      / = hidden_field_tag :process_id, session[:process_id]
      / = hidden_field_tag :task_id, session[:task_id]
      / = hidden_field_tag :owner, session[:owner]
      / - session[:bpm_input_variables].each do |bpm_input_variable|
      /   = hidden_field_tag bpm_input_variable[0], bpm_input_variable[1]

      = hidden_field_tag :process_id, Rails.cache.fetch([uri.path, params[:task_id]])[:process_id]
      = hidden_field_tag :task_id, Rails.cache.fetch([uri.path, params[:task_id]])[:task_id]
      = hidden_field_tag :owner, Rails.cache.fetch([uri.path, params[:task_id]])[:owner]
      - Rails.cache.fetch([uri.path, params[:task_id]])[:bpm_input_variables].each do |bpm_input_variable|
        = hidden_field_tag bpm_input_variable[0], bpm_input_variable[1]

      #request_spare_parts
        %fieldset
          %legend.font1 Reject Return Part
          = f.simple_fields_for :request_spare_parts do |rp|
            - if rp.object.new_record?
              = rp.association :reject_return_part_reason, label_method: :reason, value_method: :id, input_html: {name: "manual_reject_return_part_reason_id"}

      #ticket_spare_part_manufacture
        %fieldset
          %legend.font1 Accept and Ready to Bundle
          = f.simple_fields_for :ticket_spare_part_manufacture do |rm|
            = rm.input :event_closed, wrapper: :append, input_html: {checked: true}
            = rm.input :ready_to_bundle, wrapper: :append, input_html: {checked: true}, label: "Ready to bundle (Needs return to manufacturer)"
            = rm.input :payment_expected_manufacture, label: "Payment Expected from Manufacturer (#{product.product_brand.currency.try(:code)}):", input_html: {class: "input_toggler"}

      = f.input :note, input_html: {value: nil}
      = simple_format ticket_spare_part.note
      = f.submit "Save", class: "btn btn-success", onclick: "Tickets.presence_validater(this, {presence: ['#ticket_spare_part_note']}); return false;"